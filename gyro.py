"""Control a gyro and accelerometer (MPU-6050 on GY-521 breakout board).

In a guy's example he does (https://github.com/kriswiner/MPU6050/blob/master/MPU6050BasicExample.ino):
1. Read WHO_AM_I to confirm connection.
2. Does a self test on accel and gyro (see MPU6050SelfTest).
3. Takes a few miliseconds of measurements to calibrate it (assumes gravity is fully on z axis (meh)).

A German guy does (https://tutorials-raspberrypi.com/measuring-rotation-and-acceleration-raspberry-pi/):
1. Take out of sleep mode.
2. Start reading data. (short and simple, so I picked the other guy's way...)

Transforming 16bit 2's complement:

    if (val >= 0x8000):
      return -((65535 - val) + 1)

`SMBUS(1)` stands for revision 1.
"""

from smbus import SMBbus # pylint: disable=import-error
from threading import Thread
from queue import Queue, Empty
from time import sleep, monotonic
import asyncio
from math import pi



def _get_instant_measures(bus, address):
  raise NotImplementedError
  # To read data we should:
  #     0. Use DATA_RDY_EN to enable interrupts on data.
  #     1. Read INT_STATUS and check DATA_RDY_INT is set.
  #     2. Read all values from sensor registers as fast as possible (in Python...).
  #     3. Read INT_STATUS and check DATA_RDY_INT was not set, otherwise we read half fucked data, so retry reading.


class Gyro:
  ADDRESS = 0x68

  # Registers we use:
  SMPLRT_DIV = 0x19
  CONFIG = 0x1A
  GYRO_CONFIG = 0x1B
  ACCEL_CONFIG = 0x1C
  FIFO_EN = 0x23
  INT_ENABLE = 0x38
  INT_STATUS = 0x3A
  USER_CTRL = 0x6A
  PWR_MGMT_1 = 0x6B
  FIFO_COUNTH = 0x72
  FIFO_COUNTL = 0x73
  FIFO_R_W = 0x74
  WHO_AM_I = 0x75

  # Gravitational constant they use (from some SO thread, others mention just 9.81).
  g = 9.80665

  # Range of the accelerometer in g per second.
  accel_g_range = [2, 4, 8, 16]

  # Degrees to radians.
  rad = pi / 180

  # Range of the gyro in degrees per second.
  gyro_deg_range = [250, 500, 1000, 2000]

  class Measure:
    __slots__ = ("time", "duration", "acceleration", "rotation")

    def __init__(self, time, duration, acceleration, rotation):
      self.time = time
      self.duration = duration
      self.acceleration = acceleration
      self.rotation = rotation


  def __init__(
      self,
      AD0: bool = False,
    ):
    """Control the MPU-6050 Gyroscope and Accelerometer (on top of the GY-521 breakout board).

    See manual at https://www.invensense.com/wp-content/uploads/2015/02/MPU-6000-Register-Map1.pdf

    Args:
      AD0: Whether the address bit is set (connected to 3V3). The sensor addres is 0x68+AD0.
    """

    # Connect to the I2C serial bus version 1.
    self.bus = SMBbus(1)
    self.address = Gyro.ADDRESS + AD0

    # How often the gyro samples its sensors and makes them available.
    self.sample_rate = None

    # Measurement range index (for both acceleration and gyro).
    self.sensors_range = None

    # We'll use a worker thread to manage the device as we need to keep getting data from it fairly often.
    self.running = True
    self.queue = Queue()
    self.commands = Queue()

    def worker_run():
      try:
        # Setup the little guy.
        self._setup()

        # Enter the loop
        while self.running:

          measure = None # TODO

          self.queue.put(("measure", measure))

          # TODO: check commands (and run em)

      except Exception as e:
        self.queue.put(("exception", e))

    self.worker = Thread(target=worker_run)


  def _setup(self):
    # Check
    # -----

    # Confirm connection by reading WHO_AM_I (which, by the way, ignores AD0).
    if self.bus.read_byte_data(self.address, Gyro.WHO_AM_I) != Gyro.ADDRESS:
      raise EnvironmentError("Gyro does not appear to be connected!")

    # Reset the device to all 0s and wait for confirmation.
    # After a reset, all registers should be 0 except SLEEP and WHO_AM_I.
    self.bus.write_byte_data(self.address, Gyro.PWR_MGMT_1, 0b11000000)
    for _ in range(100):
      if self.bus.read_byte_data(self.address, Gyro.PWR_MGMT_1) & 0b10000000 == 0:
        # The reset bit was clearer, we're good.
        break
      sleep(0.01)
    else:
      raise EnvironmentError("Gyro didn't reset within a second!")

    # Set rate
    # --------

    # From the manual.
    # > The sensor register output, FIFO output, and DMP sampling are all based on the Sample Rate.
    # > The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
    # > Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
    # > where Gyroscope Output Rate = 8kHz when the DLPF is disabled(DLPF_CFG=0 or 7), and 1kHz
    # > when the DLPF is enabled(see Register 26).
    # > Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz,
    # > the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than
    # > once.

    # Aim for the below sampling rate (Hz)
    self.sample_rate = 1000.0 / 2

    # Halve the `sample rate = gyro rate / (1 + SMPLRT_DIV)` since it's much
    # faster than the gyro bandwith (1kHz vs 256Hz).
    self.bus.write_byte_data(self.address, Gyro.SMPLRT_DIV, 1)
    # Set the DLPF_CFG low pass filter so the accelerometer band gyro sampling
    # both go to 1kHz so they're a bit more in sync.
    self.bus.write_byte_data(self.address, Gyro.CONFIG, 0b001)


    # Enable FIFO
    # -----------

    # Allow interrupts from data ready and FIFO overflow. We need to know if it
    # overflowed since the data won't be alligned anymore and oops.
    self.bus.write_byte_data(self.address, Gyro.INT_ENABLE, 0b00010001)
    # Read it once to make sure it's clear.
    self.bus.read_byte_data(self.address, Gyro.INT_STATUS)


    # Enable the FIFO storage for gyro x, y, z and accel x, y, z measurements.
    self.bus.write_byte_data(self.address, Gyro.FIFO_EN, 0b01111000)
    # Enable FIFO.
    self.bus.write_byte_data(self.address, Gyro.USER_CTRL, 0b01000000)

    # Finalize sensors and start
    #---------------------------

    self._set_sensors_range(0)

    # Turn off sleep mode and switch the clock to gyro x (says in the manual
    # it's better than internal clock.)
    self.bus.write_byte_data(self.address, Gyro.PWR_MGMT_1, 0b00000001)

    # TODO: do the test sequence thingy

  def _set_sensors_range(self, sensors_range):
    assert sensors_range in (0, 1, 2, 3)
    # TODO: disable FIFO_EN for the sensors.

    # Get all measures so we don't waste anything.
    self._get_measures()

    # Set the range of the gyro and accelerometer.
    self.bus.write_byte_data(self.address, Gyro.GYRO_CONFIG, sensors_range << 3)
    self.bus.write_byte_data(self.address, Gyro.ACCEL_CONFIG, sensors_range << 3)
    # Use the new range from now.
    self.sensors_range = sensors_range

    # TODO: reset fifo and re-enable FIFO_EN


  def _get_measures(self):
    # FIFO max size is 1024 bytes. Which at 0.5 kHz sample rate and using 6
    # measures of 2 bytes each, means we have to 170ms worth of memory.

    # TODO:
    # To read FIFO probably simplest way would be to read FIFO_COUNT make sure
    # it's >= 12, then read 12 bytes at a time, then double check FIFO_OFLOW_INT
    # wasn't set. If it was, then use FIFO_RESET to discard partial data.
    # Otherwise, if all good, parse the 6 sensor measures and push to queue.
    # Then keep going while still something in the FIFO.


    #     3. Read INT_STATUS and check FIFO_OFLOW_INT was not set, otherwise reset the FIFO with FIFO_RESET, signal the user, and resume.
    #     4. Read FIFO_COUNT, then read as many bytes from FIFO_R_W.

    pass
    # TODO: dump the FIFO into the queue


  def measure(self):
    try:
      what, item =  self.queue.get_nowait()
    except Empty:
      return None

    if what == "measure":
      return item

    elif what == "exception":
      raise ValueError("Error while reading gyro!") from item

    else:
      raise ValueError("Unknown object in queue: {}".format(what))

  def __aiter__(self):
    return self

  async def __anext__(self):
    while self.running:
      m = self.measure()
      if m is None:
        asyncio.sleep(0.5 / self.sample_rate)
      else:
        return m
    else:
      raise StopAsyncIteration

  def __del__(self):
    # Tell the worker thread to stop.
    self.running = False

    # Let it finish.
    self.worker.join()

    self.bus.close()
